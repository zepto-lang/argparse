(define (argparse:in-args? x) "checks whether x is in args"
  (let* ((arg-prefix "--")
         (search (++ arg-prefix x)))
    (in? (lambda (y) (string=? search y)) args)))

(define (argparse:arg-value? x) "return value of x; otherwise returns nil"
  (let* ((args-vec (list->vector args))
         (arg-prefix "--")
         (search (++ arg-prefix x))
         (string-prefix (lambda (prefix el) 
                          (let ((len (string-length prefix)))
                            (eq? prefix (substring el 0 len)))))
         (i (+ (list-index args search) 1)))
    (if (or (>= i (vector-length args-vec)) (= i 0))
      :no
      (let ((found (vector-ref args-vec i)))
        (if (string-prefix arg-prefix found)
          :wrong
          found)))))

(define (argparse:arg-list-parse l) 
  "return specified arguments as list; 
    e.g. input:  '('(\":foo\" :number) '(\"bar\" :string))
         output: '((\"foo\" 10) (\"bar\" \"test\"))"
  (let ((handle (lambda (el)
            (let* ((dflt (lambda (x)
                    (if (> (length x) 2)
                      (list-ref x 2)
                      :wrong)))
                   (default (dflt el))
                   (type (list-ref el 1))
                   (name (list-ref el 0))
                   (value (argparse:arg-value? name))
                   (make (curry list name))
                   (wrap-wrong (lambda (x d) (if x d x))))
              (cond ((no? value)
                      (if (eq? type :boolean)
                        (make (argparse:in-args? name))
                        (make (wrap-wrong (argparse:in-args? name) default))))
                    ((wrong? value) (make value))
                    (else (cond ((eq? type :number) (make (string->number value)))
                                ((eq? type :string) (make value))
                                ((eq? type :list) (make (string->list value)))
                                ((eq? type :vector) (make (string->list (list->vector value))))
                                ((eq? type :symbol) (make (string->symbol value)))
                                ((eq? type :integer) (make (string->integer value)))
                                ((eq? type :small) (make (make-small (small (string->integer value)))))
                                ((eq? type :float) (make (string->float value)))
                                ((eq? type :rational) (make (string->rational value)))
                                ((eq? type :complex) (make (string->complex value)))
                                (else (make :error)))))))))
  (make-hash [(handle x) | x <- l])))

