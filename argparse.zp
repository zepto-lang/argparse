(define (argparse:in-booleans? x) "checks whether x is in boolean args"
  (let* ((arg-prefix "-"))
    (begin
      (define all
        (string-join 
          (filter (lambda (y) (and
                                (string=? arg-prefix (substring y 0 1))
                                (not (string=? arg-prefix (substring y 1 2)))))
                   args)))
      (in? (lambda (el) (string=? (string el) x)) (string->list all)))))

(define (argparse:in-args? x) "checks whether x is in args"
  (let* ((arg-prefix "--")
         (search (++ arg-prefix x)))
    (in? (lambda (y) (string=? search y)) args)))

(define (argparse:arg-value? x) "return value of x; otherwise returns nil"
  (let* ((args-vec (list->vector args))
         (arg-prefix "--")
         (search (++ arg-prefix x))
         (string-prefix (lambda (prefix el) 
                          (let ((len (string-length prefix)))
                            (eq? prefix (substring el 0 len)))))
         (i (+ (list-index args search) 1)))
    (if (or (>= i (vector-length args-vec)) (= i 0))
      :no
      (let ((found (vector-ref args-vec i)))
        (if (string-prefix arg-prefix found)
          :wrong
          found)))))

(define (argparse:print-usage name l)
  (let ((names (reduce (lambda (acc x) (++ acc (x "name") "|")) "" l)))
    (begin 
      (display (++ "usage: " name " ["))
      (display (substring names 0 (- (string-length names) 1)))
      (write "]")
      (map (lambda (x) 
              (begin
                (display "\t")
                (display (x "name"))
                (display ":\t")
                (write (x "usage"))))
            l)
      (nil))))

(define (argparse:arg-list-parse l) 
  "return specified arguments as list; 
    e.g. input:  '('(\":foo\" :number) '(\"bar\" :string))
         output: '((\"foo\" 10) (\"bar\" \"test\"))"
  (let ((handle (lambda (el)
            (let* ((dflt (lambda (x)
                    (if (hash-contains? x "default")
                      (x "default")
                      :wrong)))
                   (default (dflt el))
                   (type (el "type"))
                   (name (el "name"))
                   (short (el "short"))
                   (value (argparse:arg-value? name))
                   (make (curry list name))
                   (wrap-wrong (lambda (x d) (if x :wrong d)))
                   (string->small (lambda (x)
                                    (if (boolean? (string->integer x)
                                      x
                                      (make-small (string->integer x))))))
                   (wrong (lambda (x) (if (boolean? x) :wrong x))))
              (cond ((no? value)
                      (if (eq? type :boolean)
                        (make (or (argparse:in-args? name) 
                                  (if (nil? short)
                                    #f
                                    (argparse:in-booleans? short))))
                        (make (wrap-wrong (argparse:in-args? name) default))))
                    ((wrong? value) (make value))
                    (else (cond ((eq? type :number) (make (wrong (string->number value))))
                                ((eq? type :string) (make value))
                                ((eq? type :list) (make (string->list value)))
                                ((eq? type :vector) (make (list->vector (string->list value))))
                                ((eq? type :symbol) (make (string->symbol value)))
                                ((eq? type :integer) (make (wrong (string->integer value))))
                                ((eq? type :small) (make (wrong (string->small value))))
                                ((eq? type :float) (make (wrong (string->float value))))
                                ((eq? type :rational) (make (wrong (string->rational value))))
                                ((eq? type :complex) (make (wrong (string->complex value))))
                                (else (make :error)))))))))
  (make-hash [(handle x) | x <- l])))

(define (argparse:handle-args name l)
  (let ((x (argparse:arg-list-parse l)))
    (if (>= (list-index (hash-values x) :wrong) 0)
      (argparse:print-usage name l)
      x)))
