(define (argparse:in-args? x) "checks whether x is in args"
  (let* ((arg-prefix "--")
         (search (+= arg-prefix x)))
    (in? (lambda (y) (string=? search y)) args)))

(define (argparse:arg-value? x) "return value of x; otherwise returns nil"
  (let* ((args-vec (list->vector args))
         (arg-prefix "--")
         (search (+= arg-prefix x))
         (i (+ (list-index args search) 1)))
    (if (or (>= i (vector-length args-vec)) (= i 0))
      (nil)
      (vector-ref args-vec i))))

(define (argparse:arg-list-parse l) 
  "return specified arguments as list; 
    e.g. input:  '('(\":foo\" :number) '(\"bar\" :string))
         output: '('(\"foo\" 10) '(\"bar\" \"test\"))"
  (let ((handle (lambda (el)
            (let ((type (cadadr el))
                  (value (argparse:arg-value? (caadr el)))
                  (make (curry list (caadr el)))
                  (wrap-error (lambda (x) (if x x :no))))
              (if (nil? value)
                  (make (wrap-error (argparse:in-args? (caadr el))))
                  (cond ((eq? type :number) (make (string->number value)))
                        ((eq? type :string) (make value))
                        ((eq? type :list) (make (string->list value)))
                        ((eq? type :symbol) (make (string->symbol value)))
                        ((eq? type :boolean) (make (in-args? caadr el)))
                        ((eq? type :integer) (make (string->integer value)))
                        ((eq? type :small) (make-small (small (string->integer value))))
                        ((eq? type :float) (make (string->float value)))
                        ((eq? type :rational) (make (string->rational value)))
                        ((eq? type :complex) (make (string->complex value)))
                        (else (make :error))))))))
  [(handle x) | x <- l]))

